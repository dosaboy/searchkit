""" Search definitions implementations. """
import re
import uuid
from functools import cached_property

from searchkit.exception import FileSearchException
from searchkit.log import log


class SearchDefBase():
    """ Base class for search definition implementations. """
    def __init__(self, constraints=None):
        """
        @param constraints: an optional list of constraints to apply to
                            results.
        """
        self._constraints = constraints or {}
        # ensure uuid is generated
        _ = self.id

    @property
    def constraints(self):
        return {c.id: c for c in self._constraints}

    @cached_property
    def id(self):
        """ A unique identifier for this search definition. """
        return str(uuid.uuid4())


class SearchDef(SearchDefBase):
    """ Simple search definition.

    Search definition used to identify content in a single line.
    """
    def __init__(self, pattern, tag=None, hint=None,  # noqa, pylint: disable=too-many-arguments
                 store_result_contents=True, field_info=None, **kwargs):
        """
        Simple search definition.

        @param pattern: pattern or list of patterns to search for
        @param tag: optional user-friendly identifier for this search term.
                    This is useful for retrieving results.
        @param hint: optional pre-search term. If provided, this is expected to
                     match in order for the main search to be executed.
        @param store_result_contents: by default the content of a search result
                                      is saved but if it is not needed this
                                      can be set to False. This effectively
                                      makes the result True/False.
        @param field_info: optional ResultFieldInfo object
        """
        if not isinstance(pattern, list):
            self.patterns = [re.compile(pattern)]
        else:
            self.patterns = []
            for _pattern in pattern:
                self.patterns.append(re.compile(_pattern))

        self.store_result_contents = store_result_contents
        self.tag = tag
        self.field_info = field_info
        self.hint = hint
        if hint:
            self.hint = re.compile(hint)

        self.sequence_def = None

        # do this last
        super().__init__(**kwargs)

    def link_to_sequence(self, sequence_def, tag):
        """
        If this search definition is part of a sequence, the parent
        SequenceSearchDef must link itself to this object.

        @param sequence_def: SequenceSearchDef object
        @param tag: SequenceSearchDef object tag for this section def
        """
        self.sequence_def = sequence_def
        self.tag = tag

    def run(self, line):
        """ Execute search patterns against line and return first match. """
        if self.hint:
            ret = self.hint.search(line)
            if not ret:
                return None

        ret = None
        for pattern in self.patterns:
            ret = pattern.match(line)
            if ret:
                break

        return ret

    def __repr__(self):
        return ', '.join([str(p) for p in self.patterns])


class SequenceSearchDef(SearchDefBase):
    """ Sequence search definition.

    Search definition used to identify content that spans multiple lines.
    """
    def __init__(self, start, tag, end=None, body=None, **kwargs):
        """
        Sequence search definition.

        A sequence must match a start and end with optional body in between.
        If no end is defined, the sequence ends with the start of the next or
        EOF.

        NOTE: sequences must not overlap. This is therefore not suitable for
        finding sequences generated by parallel/concurrent tasks.

        @param start: SearchDef object for matching start
        @param tag: tag used to identify this sequence definition
        @param end: optional SearchDef object for matching end
        @param body: optional SearchDef object for matching body
        """
        self.tag = tag
        self.s_start = start
        self.s_end = end
        self.s_body = body

        # make sure section defs have tags synced with this object
        for sd, _tag in {start: self.start_tag,
                         end: self.end_tag,
                         body: self.body_tag}.items():
            if sd:
                sd.link_to_sequence(self, _tag)

        self._mark = None
        # Each section matched gets its own id. Since each file is processed
        # using a separate process and memory is not shared, these values must
        # be unique to avoid collisions when results are aggregated.
        self._section_id = None
        self.completed_sections = []
        # do this last
        super().__init__(**kwargs)

    @property
    def start_tag(self):
        """ Tag used to identify start of section. """
        return f"{self.tag}-start"

    @property
    def end_tag(self):
        """ Tag used to identify end of section. """
        return f"{self.tag}-end"

    @property
    def body_tag(self):
        """ Tag used to identify body of section. """
        return f"{self.tag}-body"

    @property
    def current_section_id(self):
        """ ID of current section. A new id should be set after each
        completed section. """
        return self._section_id

    @property
    def started(self):
        """ Indicate a section sequence has been started. """
        return self._mark == 1

    def start(self):
        """ Indicate that a sequence start has been detected. """
        self._section_id = str(uuid.uuid4())
        log.debug("sequence %s started section %s (completed=%s)",
                  self.id, self.current_section_id,
                  len(self.completed_sections))
        self._mark = 1

    def reset(self):
        """ Used to restart a section. This is used e.g. if the start
        expression matches midway through a sequence (and before the end).
        """
        self._mark = 0

    def stop(self):
        """ Indicate that a sequence is complete. """
        self._mark = 0
        if self.current_section_id is None:
            raise FileSearchException("sequence section id is None")

        self.completed_sections.append(self.current_section_id)
        log.debug("sequence %s stopping section %s (completed=%s)",
                  self.id, self.current_section_id,
                  len(self.completed_sections))
        self._section_id = str(uuid.uuid4())

    def __repr__(self):
        return (f"{self.__class__.__name__}: "
                f"current_section={self.current_section_id}, "
                f"started={self.started}, "
                f"completed_sections={self.completed_sections}")
